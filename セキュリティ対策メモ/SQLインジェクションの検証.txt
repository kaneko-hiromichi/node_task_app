SQLインジェクション攻撃

1. 攻撃例
攻撃者の入力

    メールアドレスフィールド: ' OR '1'='1
    パスワードフィールド: 任意の値（例: password）

生成されるSQLクエリ

sql

SELECT * FROM users WHERE email = '' OR '1'='1' AND password = 'password';

クエリの評価

    email = '' は常に偽 (FALSE) 
    OR '1'='1' は常に真 (TRUE) 
    結果として、クエリ全体が真 (TRUE) となり、データベースは users テーブルの全てのレコードを返す可能性

    補足：SQLの特徴の一つとして、ORが真になった後のANDは無視される
    つまり、passwordの照合を無視されてしまう

2. 攻撃の意図、期待される成果

    認証バイパス:
        認証をバイパスしてシステムに不正にログインすること。
        例: 攻撃者が管理者アカウントにログインし、システム全体の制御を奪う。

    データベースの内容取得:
        データベース内の機密情報（ユーザー名、パスワード、個人情報など）を取得すること。

    データの改ざん:
        データベースの内容を変更すること。
        例: 他のユーザーのパスワードを変更する、商品価格を変更する。

3. 今回のコードでよかった点

    プリペアドステートメントの使用:

    javascript

db.get("SELECT * FROM users WHERE email = ?", [email], async (err, user) => {

    ? プレースホルダを使用してクエリを準備し、ユーザー入力を安全にバインドしています。
    これにより、ユーザー入力がSQLクエリの構造を変更することができず、SQLインジェクション攻撃が防止されます。

    さらに、emailの照合とpasswordの照合を分けて記述しているのもポイント

パスワードのハッシュ化と検証:

javascript

    else if (!(await bcrypt.compare(password, user.password))) {

        ハッシュ化されたパスワードとユーザーが入力したパスワードを比較し、一致するかどうかを確認しています。

4. 脆弱なコード例

    ユーザー入力を直接クエリに埋め込む例:

    javascript

    const email = req.body.email;
    const query = `SELECT * FROM users WHERE email = '${email}'`;
    db.get(query, (err, user) => {
      // 処理内容
    });

    問題点:
        ユーザー入力を直接クエリに埋め込むと、SQLインジェクション攻撃に対して非常に脆弱になります。
        攻撃者が特定のペイロードを入力することで、クエリの構造が変更され、不正なデータベース操作が可能になります。

まとめ

    攻撃例:
        メールアドレスフィールドに ' OR '1'='1 を入力し、パスワードフィールドには任意の値を入力。

    攻撃の意図、期待される成果:
        認証バイパス、データベースの内容取得、データの改ざん。

    今回のコードでよかった点:
        プリペアドステートメントを使用してSQLインジェクション攻撃を防止。
        パスワードのハッシュ化と検証を適切に実施。

    脆弱なコード例:
        ユーザー入力を直接クエリに埋め込むコードは、SQLインジェクション攻撃に対して非常に脆弱。